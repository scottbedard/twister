function e(e,r){const t=(r%e.length+e.length)%e.length;return e.slice(t).concat(e.slice(0,t))}function r(e,r){if(!Number.isInteger(e)||e<3)throw new Error("Polygon sides must be an integer of 3 or greater");if(!Number.isInteger(r)||r<2)throw new Error("Polygon layers must be an integer of 2 or greater");if(3===e)throw new Error("Pyramids are not implemented yet");const t=[];for(let n=0,s=Math.floor(r/2);n<s;n++){const s=(r-2*n-1)*e;for(let e=0;e<s;e++)t.push({center:!1,currentIndex:e,depth:n,meta:{},originalIndex:e})}return r%2&&t.push({center:!0,currentIndex:0,depth:Math.floor(r/2),meta:{},originalIndex:0}),{layers:r,sides:e,stickers:t}}function t(e,r,t){if(!Number.isInteger(r)||r<0)throw new Error("Slice depth must be a positive integer");if(!Number.isInteger(t)||t<0)throw new Error("Slice angle must be a positive integer");return[]}function n(r,t){if(!Number.isInteger(t))throw new Error("Face rotations must be an integer");const n=[];t%=r.sides;for(let s=0,o=Math.floor(r.layers/2);s<=o;s++){const o=r.stickers.filter(e=>e.depth===s);if(t&&o.length>1){const s=o.length/r.sides*-t;s&&n.push(...e(o,s))}else n.push(...o)}return Object.assign(Object.assign({},r),{stickers:n})}function s(e,r){const t=Math.floor(r/2);return function(e,r){return new Array(e).fill(r)}(r).map((r,n)=>({center:t===n,data:null,originalIndex:n,value:e}))}class o extends class{constructor(e){this.options=e,this.reset()}}{constructor(e){if(!Number.isInteger(e.size))throw new Error("Cube size must be an integer");if(e.size<2)throw new Error("Cube size must be two or greater");super(e)}applyTurn(e){}isSolved(){return!1}reset(){const e=Math.pow(this.options.size,2);this.state={U:s(0,e),L:s(1,e),F:s(2,e),R:s(3,e),B:s(4,e),D:s(5,e)}}}export{o as Cube,r as createFace,t as extractSlice,n as rotateFace};
